(define-library (kallcc regflat)
  (import (scheme base)
          (scheme list)
          (scheme write);
          (scheme hash-table);
          (onif idebug);
          (prefix (kallcc symbol) ksymbol/)
          (prefix (kallcc misc) kmisc/))
  (export regflat)
  (begin

    (define (%simple-ope? ope)
      (and (ksymbol/kallcc-symbol? ope)
           (case (ksymbol/ref-symbol ope)
              ((CONS CAR CDR REG-THREAD) #t)
              (else #f))))

    (define (%drop-cont expression)
      (cons* (car expression)
             '()
             (cddr expression)))

    (define (%update-cont cont-lambda new-body)
      (if (pair? cont-lambda)
        (list (car cont-lambda)
              (cadr cont-lambda)
              (list-ref cont-lambda 2)
              new-body)
        cont-lambda))

    (define (%new-thread thread-op cont-name code next)
      (if (and (pair? next) (eq? (car next) thread-op))
        (list thread-op
              (cadr next)
              (cons (list cont-name (%drop-cont code))
                    (list-ref next 2)))
        (list thread-op (cadr next)
                        (list (list cont-name (%drop-cont code))
                              (list '() (%drop-cont next))))))

    (define (regflat-loop code thread-op)
      (let loop ((code code))
        (let ((operator (and (pair? code)
                             (ksymbol/kallcc-symbol? (car code))
                             (ksymbol/ref-symbol (car code)))))
          (case operator
            ((#f) code)
            ((DEFINE)
             (list (car code)
                   (cadr code)
                   (list-ref  code 2)
                   (loop (list-ref code 3))))
            ((LAMBDA-META)
              (list (car code)
                    (cadr code)
                    (list-ref code 2)
                    (loop (list-ref code 3))))
            ((CONS CAR CDR THREAD>)
             (let* ((next (and (pair? (cadr code))
                               (loop (%cont-decompose (cadr code))))))
               (if (and (pair? next)
                        (%simple-ope? (car next)))
                 (%new-thread thread-op (car (cadr (cadr code))) code next)
                 (cons* (car code)
                        (%update-cont (cadr code) next)
                        (cddr code)))))
            (else code)))))

    (define (%cont-decompose meta-lambda) (list-ref meta-lambda 3))

    (define (regflat expression symbol-env)
      (let ((thread-op (cadr (hash-table-ref symbol-env 'REG-THREAD))))
        (display "IN: ")(onif-idebug/debug-display expression '(not-contain-meta-info #t))(newline)
        (let ((out  (regflat-loop expression thread-op)))
          (newline)(display "OUT:")
          (if (eq? (and (pair? out) (car out)) thread-op)
            (begin (display "{")(display ":op , ")(onif-idebug/debug-display (list-ref out 2) '(not-contain-meta-info #t))(newline)
                    (display ":cont , ")(onif-idebug/debug-display  (list-ref out 1) '(not-contain-meta-info #t))(display "}"))
            (onif-idebug/debug-display out '(not-contain-meta-info #t)))
          (newline)
        out)))
      ))
